# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'Case-weight adjusted solution path for L2 regularized nonsmooth problem (quantile regression and svm)
#'
#' @description
#' Path-following algorithm to exactly solve 
#' 	(beta_{0,w}, beta_{w}) = argmin_{beta_0, beta} \sum_{i \neq j} f(g_i(beta_0, beta)) + w*f(g_{j}(beta_0, beta)) + lambda / 2 * \|beta\|_2^2
#' for 0 <= w <= 1, where g_i(beta_0, beta) = a_i beta_0 + b_i^T beta + c_i and f(r) = alpha_0 max(r, 0) + alpha_1 max(-r, 0)
#'
#' @param a A \eqn{n \times 1} vector and a^T = (a_1, ..., a_n)
#' @param B A \eqn{n \times p} matrix and B^T = (b_1, ..., b_n)
#' @param c A \eqn{n \times 1} matrix and c^T = (b_1, ..., b_n) 
#' @param lam Regularization parameter for L2 penalty
#' @param alpha_0 A scalar in the definition of f(r)
#' @param alpha_1 A scalar in the definition of f(r)
#' @param j Index of the observation that is attached a weight
#' @param beta_0_w0 A scalar, which is the true value of beta_{0,w} when w = w_0 = 1
#' @param beta_w0 A \eqn{p \times 1} vector, which is the true value of beta_{w} when w = w_0 = 1
#' @param theta_w0 A \eqn{n \times 1} vector, which is the true value of the dual variable when w = w_0 = 1
#'
#' @details
#' This function will be called by function CaseInfluence_nonsmooth to generate case influence graph for each case.
#'
#' @return W_vec A list of breakout points
#' @return Beta_0 True values of beta_{0,w} at breakout points
#' @return Beta True values of beta_{w} at breakout points
NULL

#'Compute global influence for each case under L2 regularized nonsmooth problem 
#'
#' @description
#' Compute the global influence/Cook's distance for each case under L2 regularized nonsmooth problem (quantile regression and svm).
#'
#' @param a A \eqn{n \times 1} vector and a^T = (a_1, ..., a_n)
#' @param B A \eqn{n \times p} matrix and B^T = (b_1, ..., b_n)
#' @param c A \eqn{n \times 1} matrix and c^T = (b_1, ..., b_n) 
#' @param lam Regularization parameter for L2 penalty
#' @param alpha_0 A scalar in the definition of f(r)
#' @param alpha_1 A scalar in the definition of f(r)
#' @param beta_0_w0 A scalar, which is the true value of beta_{0,w} when w = w_0 = 1
#' @param beta_w0 A \eqn{p \times 1} vector, which is the true value of beta_{w} when w = w_0 = 1
#' @param theta_w0 A \eqn{n \times 1} vector, which is the true value of the dual variable when w = w_0 = 1
#' @param model_class The model we consider, two options are "quantile" and "svm"
#' @param influence_measure The influence measure used to compute global influence for each case, two options are "FMD" and "BDLD". It is only used when
#' model_class = "svm"
#'
#' @details
#' This function will be called by the main function Compute_CaseInflu_nonsmooth to generate case influence graph for each case.
#'
#' @return CaseInfluence_vec Global influence for each case
#' @return cook_distance Cook's distance for each case
CaseInfluence_nonsmooth <- function(a, B, c, lam, alpha_0, alpha_1, beta_0_w0, beta_w0, theta_w0, model_class, influence_measure) {
    .Call(`_Caseinflu_CaseInfluence_nonsmooth`, a, B, c, lam, alpha_0, alpha_1, beta_0_w0, beta_w0, theta_w0, model_class, influence_measure)
}

#'Compute local influence for each case under L2 regularized nonsmooth problem
#'
#' @description
#' Compute the local influence for each case under L2 regularized nonsmooth problem (quantile regression and svm), 
#' and the procedure only depends on the full-data solution.
#'
#' @param a A \eqn{n \times 1} vector and a^T = (a_1, ..., a_n)
#' @param B A \eqn{n \times p} matrix and B^T = (b_1, ..., b_n)
#' @param c A \eqn{n \times 1} matrix and c^T = (b_1, ..., b_n) 
#' @param lam Regularization parameter for L2 penalty
#' @param alpha_0 A scalar in the definition of f(r)
#' @param alpha_1 A scalar in the definition of f(r)
#' @param beta_0_w0 A scalar, which is the true value of beta_{0,w} when w = w_0 = 1
#' @param beta_w0 A \eqn{p \times 1} vector, which is the true value of beta_{w} when w = w_0 = 1
#' @param theta_w0 A \eqn{n \times 1} vector, which is the true value of the dual variable when w = w_0 = 1
#' @param model_class The model we consider, two options are "quantile" and "svm"
#' @param influence_measure The influence measure used to compute global influence for each case, two options are "FMD" and "BDLD". It is only used when
#' model_class = "svm"
#'
#' @details
#' This function will be called by the main function Compute_LocalInflu_nonsmooth to compute local influence for each case.
#'
#' @return LocalInfluence_vec Local influence for each case
LocalInfluence_nonsmooth <- function(a, B, c, lam, alpha_0, alpha_1, beta_0_w0, beta_w0, theta_w0, model_class, influence_measure) {
    .Call(`_Caseinflu_LocalInfluence_nonsmooth`, a, B, c, lam, alpha_0, alpha_1, beta_0_w0, beta_w0, theta_w0, model_class, influence_measure)
}

#'Case-weight adjusted solution path for logistic regression Newton method (\eqn{p \le n})
#'
#' @description
#' Generate solution path for case-weight adjusted problem by adopting Newton method at each selected grid points,
#' which are adaptively selected to save computation while maintaining the accuracy of the entire path.
#'
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param theta_0 A \eqn{p \times 1} vector that corresponds to full-data solution
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param lam Regularization parameter for L2 penalty
#' @param case_index Index of the observation that is attached a weight
#' @param epsilon Pre-specified error tolerance of the entire path
#' @param L Lipschitz constant for the gradient of the loss function
#'
#' @details
#' This function will be called by the function CaseInfluence_logistic to generate case influence graph for each case, with method = "Newton".
#'
#' @return t_vec Adaptively selected grid points
#' @return theta Generated soultion path at grid points
#' @return alpha_t Step size between grid points
NULL

#'Case-weight adjusted solution path for logistic regression Newton method (\eqn{n \le p})
#'
#' @description
#' Generate solution path for case-weight adjusted problem by adopting Newton method at each selected grid points,
#' which are adaptively selected to save computation while maintaining the accuracy of the entire path.
#'
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param theta_0 A \eqn{p \times 1} vector that corresponds to full-data solution
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param lam Regularization parameter for L2 penalty
#' @param case_index Index of the observation that is attached a weight
#' @param epsilon Pre-specified error tolerance of the entire path
#' @param L Lipschitz constant for the gradient of the loss function
#'
#' @details
#' This function will be called by the function CaseInfluence_logistic to generate case influence graph for each case, with method = "Newton".
#'
#' @return t_vec Adaptively selected grid points
#' @return theta Generated soultion path at grid points
#' @return alpha_t Step size between grid points
NULL

#'Case-weight adjusted solution path for logistic regression gradient descent method
#'
#' @description
#' Generate solution path for case-weight adjusted problem by adopting gradient descent method at each selected grid points,
#' which are adaptively selected to save computation while maintaining the accuracy of the entire path.
#'
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param theta_0 A \eqn{p \times 1} vector that corresponds to full-data solution
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param lam Regularization parameter for L2 penalty
#' @param case_index Index of the observation that is attached a weight
#' @param epsilon Pre-specified error tolerance of the entire path
#' @param L Lipschitz constant for the gradient of the loss function
#'
#' @details
#' This function will be called by the function CaseInfluence_logistic to generate case influence graph for each case, with method = "GD".
#'
#' @return t_vec Adaptively selected grid points
#' @return theta Generated soultion path at grid points
#' @return alpha_t Step size between grid points
NULL

#' Compute the LOO solution for L2 regularized logistic regression 
#'
#' @description
#' Given the initial point, compute the LOO solution for L2 regularized logistic regression by one-step Newton method
#'
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param theta_init A \eqn{p \times 1} vector, which is the initial point
#' @param lam Regularization parameter for L2 penalty
#' @param case_index Index of the observation that is left out
#'
#' @return theta_loo Computed LOO solutions
NULL

#'Case-weight adjusted solution path for poisson regression Newton method (\eqn{n \le p})
#'
#' @description
#' Generate solution path for case-weight adjusted problem by adopting Newton method at each selected grid points,
#' which are adaptively selected to save computation while maintaining the accuracy of the entire path.
#'
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param theta_0 A \eqn{p \times 1} vector that corresponds to full-data solution
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param lam Regularization parameter for L2 penalty
#' @param case_index Index of the observation that is attached a weight
#' @param epsilon Pre-specified error tolerance of the entire path
#' @param L Lipschitz constant for the gradient of the loss function
#'
#' @details
#' This function will be called by the function CaseInfluence_poisson to generate case influence graph for each case, with method = "Newton".
#'
#' @return t_vec Adaptively selected grid points
#' @return theta Generated soultion path at grid points
#' @return alpha_t Step size between grid points
NULL

#'Case-weight adjusted solution path for poisson regression Newton method (\eqn{p \le n})
#'
#' @description
#' Generate solution path for case-weight adjusted problem by adopting Newton method at each selected grid points,
#' which are adaptively selected to save computation while maintaining the accuracy of the entire path.
#'
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param theta_0 A \eqn{p \times 1} vector that corresponds to full-data solution
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param lam Regularization parameter for L2 penalty
#' @param case_index Index of the observation that is attached a weight
#' @param epsilon Pre-specified error tolerance of the entire path
#' @param L Lipschitz constant for the gradient of the loss function
#'
#' @details
#' This function will be called by the function CaseInfluence_poisson to generate case influence graph for each case, with method = "Newton".
#'
#' @return t_vec Adaptively selected grid points
#' @return theta Generated soultion path at grid points
#' @return alpha_t Step size between grid points
NULL

#'Case-weight adjusted solution path for poisson regression gradient descent method
#'
#' @description
#' Generate solution path for case-weight adjusted problem by adopting gradient descent method at each selected grid points,
#' which are adaptively selected to save computation while maintaining the accuracy of the entire path.
#'
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param theta_0 A \eqn{p \times 1} vector that corresponds to full-data solution
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param lam Regularization parameter for L2 penalty
#' @param case_index Index of the observation that is attached a weight
#' @param epsilon Pre-specified error tolerance of the entire path
#' @param L Lipschitz constant for the gradient of the loss function
#'
#' @details
#' This function will be called by the function CaseInfluence_poisson to generate case influence graph for each case, with method = "GD".
#'
#' @return t_vec Adaptively selected grid points
#' @return theta Generated soultion path at grid points
#' @return alpha_t Step size between grid points
NULL

#' Compute the LOO solution for L2 regularized poisson regression 
#'
#' @description
#' Given the initial point, compute the LOO solution for L2 regularized poisson regression by one-step Newton method
#'
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param theta_init A \eqn{p \times 1} vector, which is the initial point
#' @param lam Regularization parameter for L2 penalty
#' @param case_index Index of the observation that is left out
#'
#' @return theta_loo Computed LOO solutions
NULL

#'Compute global influence for each case under logistic regression
#'
#' @description
#' Compute the global influence/Cook's distance for each case under logistic regression.
#'
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param theta_0 A \eqn{p \times 1} vector that corresponds to full-data solution
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param lam Regularization parameter for L2 penalty
#' @param epsilon Pre-specified error tolerance of the entire path
#' @param method The method to use at each grid point, two options are "Newton" and "GD"
#' @param influence_measure The influence measure used to compute global influence for each case, two options are "FMD" and "BDLD"
#'
#' @details
#' This function will be called by the main function Compute_CaseInflu_GLM, with class = "logistc".
#'
#' @return global_influence Global influence for each case
#' @return cook_distance Cook's distance for each case
CaseInfluence_logistic <- function(X, Y, theta_0, t_max, lam, epsilon, method, influence_measure) {
    .Call(`_Caseinflu_CaseInfluence_logistic`, X, Y, theta_0, t_max, lam, epsilon, method, influence_measure)
}

#'Compute local influence for each case under logistic regression
#'
#' @description
#' Compute the local influence for each case under logistic regression.
#'
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param theta_0 A \eqn{p \times 1} vector that corresponds to full-data solution
#' @param lam Regularization parameter for L2 penalty
#' @param influence_measure The influence measure used to compute global influence for each case, two options are "FMD" and "BDLD"
#'
#' @details
#' This function will be called by the main function Compute_LocalInflu_GLM, with class = "logistic".
#'
#' @return LocalInfluence_vec Local influence for each case
LocalInfluence_logistic <- function(X, Y, theta_0, lam, influence_measure) {
    .Call(`_Caseinflu_LocalInfluence_logistic`, X, Y, theta_0, lam, influence_measure)
}

#'Compute global influence for each case under Poisson regression
#'
#' @description
#' Compute the global influence/Cook's distance for each case under Poisson regression.
#'
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param theta_0 A \eqn{p \times 1} vector that corresponds to full-data solution
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param lam Regularization parameter for L2 penalty
#' @param epsilon Pre-specified error tolerance of the entire path
#' @param method The method to use at each grid point, two options are "Newton" and "GD"
#'
#' @details
#' This function will be called by the main function Compute_CaseInflu_GLM, with class = "poisson".
#'
#' @return global_influence Global influence for each case
#' @return cook_distance Cook's distance for each case
CaseInfluence_poisson <- function(X, Y, theta_0, t_max, lam, epsilon, method) {
    .Call(`_Caseinflu_CaseInfluence_poisson`, X, Y, theta_0, t_max, lam, epsilon, method)
}

#'Compute local influence for each case under Poisson regression
#'
#' @description
#' Compute the local influence for each case under Poisson regression.
#'
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param theta_0 A \eqn{p \times 1} vector that corresponds to full-data solution
#' @param lam Regularization parameter for L2 penalty
#'
#' @details
#' This function will be called by the main function Compute_LocalInflu_GLM, with class = "poisson".
#'
#' @return LocalInfluence_vec Local influence for each case
LocalInfluence_poisson <- function(X, Y, theta_0, lam) {
    .Call(`_Caseinflu_LocalInfluence_poisson`, X, Y, theta_0, lam)
}

